Identifiers in Python

- Are case-sensitive.
- Can be composed of almost any combination of letters, numerals, and underscore characters.
- Cannot begin with a numeral.
- Cannot be any of python reserved words


The bool Class
It is used to manipulate boolean values
- only two instances of the class are expressed as literals i.e. True or False.
- python allows the creation of a Boolean value from a non-boolean type using the syntax bool(x) for value x.
- Numbers evaluate to False if zero and True if non-zero.
- Sequences and other container types evaluate to False if empty and True if nonempty.


The int Class
The *int* class is designed to represent integer values with arbitrary magnitude.
- In cases where it is convenient to express an integral value using binary, octal or hex, it can be done by using a prefix of the number 0 and then a character to describe the base.
	* Example
	  - 0x7f = 127
	  - 0o52 = 52
	  - 0b1011 = 11
- the constructor, int() returns value 0 by default
- int() can be used to construct an integer based upon an existing value of another type.
- integers passed as strings will be converted to the corresponding integer but string arguments like ('Hello') will raise a ValueError.
- if conversion to another base is required, the destination base is passed as a second argument.


The Float Class
- It is the sole floating-point type in python. its precision is alike to the double in C++ and Java.
- One can also use scientific notation to represent floating point values. For example 6.022e23 represents the value 6.022 x10^23.
- The constructor, float() returns 0.0 and when given a parameter, it attempts to return the equivalent floating-point value. For example, float(2) returns 2.0.


The list class
- A list instance stores a sequence of objects (arbitrary objects including the None object)
- It is akin to an "array" in other languages.
- Lists are array-based sequences and are zero-indexed => a list of length n has elements from 0 to n-1 inclusive.
- Python uses the [] characters to delimit lists
- [] represents an empty list
- The constructor, list() returns an empty list by default and accepts any parameter of an iterable type (e.g. strings, list, tuples, sets, dictionaries)
- Lists are mutable (content can be changed)


The tuple class
- Provides an immutable version of a sequence.
- Python uses () characters to delimit a tuple.
- 


The string class
- Python does not have a separate class for characters; they are just a strings of length one.
- Designed to represent an immutable sequence of characters.
- They can be enclosed in single 'hello' or double quotes "hello"
- For sequences of characters including the quote character, the escape character, '\' (backslash).
	* For example, to represent the sequence of characters, C:\User\Python, one will use the string literal, 'C:\\User\\Python' in python.
	* For the sequence, Don't worry, one will use, "Don't worry".
- Python also supports using the ''' and """ to denote the beginning and end of multiline text.



The set class
- Represent a collection of elements without duplicates and without a specific order to those elements.
- Two important restrictions to note:
    * a set does not maintain the elements in a specific order.
        For example:
        The code

            names = {"Achah", "John", "Doe"}
            print(names[0])

        when run produces an error
            print(names[0])
                  ~~~~~^^^
        TypeError: 'set' object is not subscriptable

    * only instances of immutable types can be added to a set in Python.
        For example
        The code
            names = {"Achah", ["John", "Doe"]}

        Produces the error
            names = {"Achah", ["John", "Doe"]}
                    ^^^^^^^^^^^^^^^^^^^^^^^^^^
        TypeError: unhashable type: 'list'

The dict class
- used to represent a mapping from a set of distinct keys to associated values.
- dictionaries were introduced to python prior to sets, consequently, the literal form {}
produces an empty dictionary not set.
- a non-empty dictionary is expressed using a  comma-separated series of key:value pairs.
- For example:
    {"la": "French", "the": "English"}

- a dictionary can be created from an exiting mapping or a sequence of key:value pairs using the dict() constructor.


Operators in Python
logical operators
    - not: negation
    - and: conditional and
    - or: conditional or

 equality operators
    - is: same identity (when identifiers are aliases for the same object)
    - is not: different
    - == : equivalent
    - != : not equivalent

 arithmetic operators
    - addition ( + )
    - subtraction ( - )
    - multiplication ( * )
    - division: ( / )
    - integer division: ( // )
 sequence operators
    - s[j] : indicates element in s sequence at index j
    - s[start:stop] : slice sequence s including start and stop indicators
    - s+t : concatenation of s and t sequences
    - k*s : short for s + s + s + ... (k times)
    - val in s: Containment check
    - val not in s : non containment check

    NB: Python uses zero-indexing and supports negative indexing
    
Control flow
    - Colon " : " character is used to delimit the beginning of a block of code
      that acts as a body for a control structure.
      NB: if the body can be stated in a singe statement, then it can be places to the right of the colon
      otherwise, indentation is used to designate the extent of the block of code or any nested blocks within it

    Conditionals (if statements): execute a block of code based on the run-time evaluation of a boolean expression
        Structure:
            if first_condition:
                first_body
            elif second_condition:
                second_body
            else:
                third_body
        Only one of the bodies of code is executed based on which condition is satisfied
        Example: robot instruction
            if door_is_closed:
                open_door()
            advance()
        Noticing the indentation level of the last statement, implies that it will always be executed meaning the robot only moves through an open door.
        another example with nesting involved
            if door_is_closed:
                if door_is_locked:
                    unlock_door()
                open_door()
            advance()
    Loops
        while loops
            structure
                while condition: (boolean expression)
                    body (block of code)
            Example
                j = 0
                while j < len(data) and data[j] != 'X':
                    j += 1

        For loops
            can be used on any kind of iterable structure.
            Structure
                for element in iterable:
                    body        in body, we may refer to "element" as an identifier

                Example1: summing elements of a list
                    total = 0
                    for val in data:
                        total += val
                2: finding max element in list
                    biggest = data[0]
                    for val in data:
                        if val > biggest:
                            biggest = val
                3: finding position of max element ( iteration using indices instead of going through the elements themselves )
                    big_index = 0
                    for i in range(len(data)):
                        if data[i] > data[big_index]:
                            big_index = i

        Break and Continue statements
            - break is used to immediately terminate the immediately enclosing loop.
            break Example:
                found = False
                for item in data:
                    if item == target:
                        found = True
                        break       #causes immediate exit of the for loop
            - Continue is used to stop the current iteration but the subsequent iterations go as expected.

Functions
    Difference between function and method (copied)
        The term 'function' will be used to describe a traditional, stateless function invoked without the context of a particular class
        or an instance of that class for example max(data), sum(data) whereas the term method is used to describe a member function invoked upon
        specific object using an object-oriented message passing syntax e.g. data.sort().
    example:
        def count(data, target):
            n = 0
            for item in data:
                if item = target:
                    n += 1
            return n
    first line beginning with "def" defines the function's signature together with the number and names of parameters it expects.
    unlike C++ or Java, the types of the parameters or return are not predefined but can be enforced in the body of the function ( Python is dynamically typed)
    after the definition, then the body; it is expressed as the indented block of code.
    NB: When a function is called, python creates an activation record which stores information relevant to the current call. some of the info includes
    the namespace which tracks and manages all identifiers within the local scope of the  current call.
    - The "return" statement is used within the body of the function to tell the function to cease execution immediately and
      return a specified value to the caller. if no value is specified to be returned, the function returns None, same as when the function ceases execution without
      the return statement.

      Example

      def contains(data, target):
        for item in data:
            if item == target:
                return True
        return False

      if the conditional within the for loop is satisfied, the return True statement is executed and the function ceases execution at that point
      but if the loop goes to completion without the conditional being ever satisfied, then the return False statement is executed, ending the function execution.

    - In a function definition, the identifiers used to describe the expected parameters are called formal parameters whereas the values passed upon invocation of the function
      are called the actual parameters. just before execution of the function call, the actual parameters are assigned to the formal parameters

    Default parameter values
        Example
            def foo(a, b=15, c=27):

            different ways of calling the function foo:
                foo(4) which will be equivalent of calling the function as foo(4,15,27)
                foo(5, 25) === foo(5, 15, 27)

            however, it is not permitted to define a function for example count(a, b=2, c)
            this is because once a parameter has a default value, all following parameters must have default values

Simple Input and Output

    Console input and output
        The print function
            - used to generate standard output to the console
            - prints a sequence of arguments separated by spaces.
            NB:
                - by default, arguments to the print function are separated with a space but a new attribute separator
                  can be defined by the user using the keyword argument 'sep'
                  For example, to produce colon-separated output, one could use

                    print(name, amount, sep=':')
                - by default, a trailing new line is printed after all arguments. this can be suppressed by using
                    the 'end' keyword argument
                    for example: print(names, ages, end=''
                - by default, the print function sends its output the console. However, the output could be directed
                  to a file.

        The input function
            It is the primary way of receiving information from the user console.
            - The function displays a prompt which can be specified as an optional parameter and then waits until the user enters
              their data and pressed the 'enter'/'return' key on the keyboard.
            - the function returns a string of characters that were entered

            Since the input function returns a string, in order to get integer values, from users, we must construct the integer or float
            from the entered data. these functions can be combined in one statement as:

            age = int(input('How old are you?'))

            Example program

                age = int(input("Enter your age in years: "))
                max_heart_rate = 206.9 - (0.67 * age)
                target = 0.65 * max_heart_rate
                print('Your target fat-burning heart rate is', target)

    Files
        - Access to a file in the beginning is made using the built-in function called open.
        - modes are optional parameters used in the function call that specify what can be done with the file.
          with 'r' being the default mode for 'read-only'.
          Other modes include 'w' for write/writing, 'a' for append

        the command fp = open('sample.txt') attempts to open a file named sample.txt in read-only mode.
        it also returns a proxy to the file.

        summary of methods for reading and writing from and to files
        fp = open(sample.txt)
        1. fp.read() : Return the (remaining) content of a readable file as a string.
        2. fp.read(k) : Return the next k bytes of a readable file as a string
        3. fp.readline() : Return (remainder of) the current line of a ...
        4. fp.readlines() : Return (remaining ) lines of a readable file as a list of strings
        5. for line in fp : iterate over remaining lines in file
        6. fp.seek(k) : change position of cursor to the kth byte of the file.
        7. fp.tell() : Return the current position as a byte-offset from the start
        8. fp.write(string) : Write given string at current position of writable file.
        9. fp.writelines(seq) : write each of the strings of the given sequence at the
           current position of the writable file. NB the command does not insert any newlines '\n' besides those already in the strings
        10. print(..., file=fp) : Redirect output of the print function to the file.


        Reading from a file
            using the read, readline or readlines functions mentioned above.

        Writing to a file
        - the file proxy must be created using with the write mode specified
            fp = open('sample.txt', w)
        - writing to the file can then be done using the 'write', writelines functions mentioned above
         or by redirecting the output of the print function to the file.

Exception Handling
    What is an exception?
        They are unexpected events that occur during the execution of a program.
        When these errors or exceptions occur, they are either caught and handled by a surrounding context or they are uncaught
        which cause the interpreter to report the appropriate message in the console
    - an exception is thrown by executing the 'raise' statement, with an appropriate instance of an exception class as an argument
      that designates the problem.
    For Example Exception handling in the sqrt function may be done as follows:
        def sqrt(x):
            if not isinstance(x, (int, float)):
                raise TypeError("x must be numeric.")
            elif x < 0:
                raise ValueError('x cannot be negative')
                .
                .
                .

    Methods of exception handling
    1. "look before you leap": handling all possibilities of exceptions being raised proactively
    2. "it is easier to ask for forgiveness than it is to get permission.": No need to spend time safeguarding
       against every possible exception as long as there is a mechanism to take care of it if it arises.
       to implement this idea, the 'try-except' block is used in python.

    Exception handling comes in really handy when dealing with unpredictable data input maybe from a user or a file.


